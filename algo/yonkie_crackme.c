#include <windows.h>
#include <wincrypt.h>
#include <stdbool.h>
#include <stdint.h>

#define ECB 1
#include "aes-min.h"

//CRC32 determined using Ghidra
int32_t crc32(int32_t namelen, uint8_t* buffer) {
	
	if (namelen <= 0) {
		return 0;
	}
	uint32_t result = 0;
	for (int i = 0; i < namelen; i++)
	{
		int bitcount = 8;
		result ^= (buffer[i] ^ 0xffffffff);
		do {
			uint32_t calc = -(result & 1) & 0xedb88320;
			result = result >> 1 ^ calc;
			bitcount--;
		} while (bitcount != 0);
		result ^= 0xffffffff;
	}
	return result;
}

void init()
{
	srand(GetTickCount());
}

void process_serial(char *name, char *serial_out)
{
	uint8_t block[AES_BLOCK_SIZE];
	uint8_t key_schedule[AES128_KEY_SCHEDULE_SIZE];
	int namelen = lstrlen(name);
	
	
	uint32_t crc = crc32(namelen,name);
	//generated by a C runtime RNG with seed 0x12345678
	BYTE aes_key[0x10]={0xE9, 0x3F, 0x0D, 0xA1, 0x96, 0x95, 0x31, 0x04, 0x49, 0x2D, 0x9E, 0x61, 0x83, 0xCF, 0x09, 0x6F};
	//from key1.dat
	//valid keydata with "Yonkie" username
	BYTE key[0x10] = {0x6A, 0x53, 0x27, 0xF3, 0x84, 0x08, 0x8C, 0xC0, 0x03, 0x11, 0x56, 0x00, 0xDC, 0x43, 0x04, 0x19};



	
	aes128_key_schedule(key_schedule, aes_key);
	//aes128_encrypt(block, key_schedule);

	//calc checksum
		int eax = key[0];
		int edx = key[1];
		edx += eax;
	for (int i = 2; i < 0x0B; i+=2)
	{
		eax = key[i];
		eax += edx;
		edx = key[i + 1];
		edx += eax;
	}
	edx = (char)edx;

	wsprintf(serial_out, "%04X", edx);
}


